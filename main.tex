\documentclass[
    english
]{VUMIFPSbakalaurinis}
\usepackage{float}
\usepackage{wrapfig2}
\usepackage{hyperref}
\usepackage{algorithmicx}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{bm}
\usepackage{caption}
\usepackage{color}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{subcaption}
\usepackage{biblatex}

\university{Vilnius university}
\faculty{Faculty of Mathematics and Informatics}
\department{Informatics bachelor's degree studies}
\title{Two chosen computer architecture comparison}
\papertype{Motorola 68HC11 vs. Intel i960}

\author{Ainis Augustas Laurinavičius}
\supervisor{prof. dr. Saulius Gražulis}
\date{Vilnius – \the\year}

\bibliography{bibliografija}

\begin{document}
\maketitle

\newpage
\section*{Base of the processor/computer, physical characteristics}
\subsection*{Motorola 68HC11}
The base of this architecture is made from CMOS MOSFET transistors, an integrated circuit (IC) with a very large scale of integration (VLSI). This processor is a monocrystalline modern processor. The processor is about 20 mm in length and 20 mm in width; its weight is not specified. During operation, the processor uses 5 V at a frequency of 2 MHz, and the current ranges between 5 and 15 mA. When the operating frequency is increased to 3–4 MHz, the current ranges from 8 to 20 mA. In STOP mode (low-power), the processor uses less — about 10 $\mu$A, and in sleep mode (WAIT), the current is not precisely specified. The processor’s power consumption during operation is between 50 and 100 mW.

\subsection*{Intel i960}
The base of this architecture is composed of CMOS transistors and an integrated circuit with a very large scale of integration (VLSI). This processor is a monocrystalline modern processor. The processor is about 35 mm in length and 35 mm in width, weighing about 50 g. During operation, the processor uses 3.3 V at a 25 MHz frequency, with a current of about 150 mA. When the operating frequency is increased to 33 MHz, the current increases to 200 mA. In STOP mode (low-power), the processor uses only 10–20 mA, and in sleep mode (WAIT) it uses 37–75 mA. The processor’s power consumption during operation is about 0.033 W.

\subsection*{Sources}
\textbf{For Motorola 68HC11:}

\url{https://grokipedia.com/page/Motorola_68HC11}

\url{https://www.nxp.com/docs/en/reference-manual/M68HC11RM.pdf}

Pages: 73 - 77

\textbf{For Intel i960:}

\url{http://www.bitsavers.org/components/intel/i960/i960_Processors_and_Related_Products_Jan95.pdf}

Pages: 182 - 184

\url{https://datasheets.chipdb.org/Intel/80960/manuals/48527606.PDF#:~:text=In%20the%20add%20and%20subtract%20with%20carry,an%20overflow%20condition%20resulted%20from%20the%20operation}

Pages: 139

\section*{What type of architecture did the computer use?}
\subsection*{Motorola 68HC11}
This architecture had an 8-bit accumulator, a stack pointer, which is not used for operations, a program counter, and registers that support 72 instructions and 19 extended opcodes. All operations are performed between registers or in the accumulator rather than in memory, so this processor’s architecture is accumulator/register based.

\subsection*{Intel i960}
This architecture is made of registers, a stack pointer, which is not used for operations. It does not have an accumulator and uses load/store instructions. All operations are performed between registers rather than in memory, so this processor’s architecture is register-based, which uses load/store instructions.

\subsection*{Sources}
\textbf{For Motorola 68HC11:}

\url{https://grokipedia.com/page/Motorola_68HC11}

\textbf{For Intel i960:}

\url{https://grokipedia.com/page/Intel_i960}

\section*{Was it a zero-address (stack-based), one-address, two-address, three-address, or four-address machine?}
\subsection*{Motorola 68HC11}
This architecture is a 1–2-address machine, where the number of addresses depends on the operation, and it never uses more than two. The architecture has a stack, but it is not used for operations (‘The M68HC11 CPU automatically supports a program stack… used for subroutines, interrupts, and temporary storage.’ — a quote from the Motorola 68HC11 Reference Manual).

\subsection*{Intel i960}
This architecture uses mostly 2 addresses. There is no one-address or three-address operation within this architecture. The architecture has a stack, but it is not used for operations (quote from the i960 Intel Datasheet: ‘it does not consume/produce operands on a stack’).

\subsection*{Sources}
\textbf{For Motorola 68HC11:}

\url{https://www.nxp.com/docs/en/reference-manual/M68HC11RM.pdf}

Page: 214

\textbf{For Intel i960:}

\url{https://www.alldatasheet.com/datasheet-pdf/download/93622/INTEL/I960.html}

Pages: 12 - 13

\section*{What registers existed in both architectures? What kind of registers were they? How many registers were there? What were the data widths of the registers? What was the specific purpose of each register?}
\subsection*{Motorola 68HC11}
The architecture has 8 registers (A, B, D, X, Y, SP, PC, CCR), and all registers are global. Registers A, B, and CCR are 8 bits wide, while the others are 16 bits wide. Registers SP and CCR have special purposes—SP is the stack pointer register, and CCR is the Condition Code Register. The PC register is the Program Counter. Registers X and Y are used for indexing but can also serve as general-purpose registers, while the remaining registers (A, B, D) are general-purpose registers.

\subsection*{Intel i960}
The architecture consists of 32 registers (16 global and 16 local general-purpose), and all registers are 32 bits wide. The special-purpose registers are: PC/IP (Instruction Pointer), AC (Arithmetic Condition Codes), and MMRs (used to control interrupts, counters, and program errors).

\subsection*{Sources}
\textbf{For Motorola 68HC11:}

\url{https://www.nxp.com/docs/en/reference-manual/M68HC11RM.pdf}

Pages: 199 - 201

\textbf{For Intel i960:}

\url{https://www.alldatasheet.com/datasheet-pdf/download/93622/INTEL/I960.html}

Pages: 1, 4 - 6

\section*{Were flag bits used in these architectures? Which flags were used?}
\subsection*{Motorola 68HC11}
Yes, this architecture uses flag bits—the CCR register contains 5 flag bits. The flag bits are: C (Carry/Borrow), V (Overflow), Z (Zero), N (Negative), and H (Half-carry).

\subsection*{Intel i960}
Yes, this architecture also uses flag bits. The flag bits are: C (Carry/Borrow), V (Two’s complement overflow indicator), Z (Zero indicator), N (Negative indicator), and T (Trace-enable, used for program debugging).

\subsection*{Sources}
\textbf{For Motorola 68HC11:}

\url{https://www.nxp.com/docs/en/reference-manual/M68HC11RM.pdf}

Page: 489

\textbf{For Intel i960:}

\url{https://www.alldatasheet.com/datasheet-pdf/download/93622/INTEL/I960.html}

Pages: 12, 13, 63

\section*{What was the data width (machine word) of each architecture?}
\subsection*{Motorola 68HC11}
The machine word for this architecture is 8 bits long.

\subsection*{Intel i960}
The machine word for this architecture is 32 bits long.

\subsection*{Sources}
\textbf{For Motorola 68HC11:}

\url{https://grokipedia.com/page/Motorola_68HC11}

\textbf{For Intel i960:}

\url{https://www.alldatasheet.com/datasheet-pdf/download/93622/INTEL/I960.html}

Page: 15

\section*{Memory layout of each system. Address width. The maximum possible amount of memory in each system. Typical amount of memory with which the system was used}

\subsection*{Motorola 68HC11}
This architure's memory is flat and linearly stored in a 64KB address space - the memory is not segmented, nor paged, nor stored in memory banks. The effective address width is 16 bits and the maximum amount of memory stored in the system was 64KB. The typical memory amount for this system is about 256–512 bytes of RAM and 8–12 KB of program memory.

\subsection*{Intel i960}
This architecture's memory layout is not segmented, nor does it use pages, but it does use memory banks(regions). The effective adress width was 32 bits and the maximum amount of memory stored in the system was up to 256 Mbytes of 32- or 36-Bit DRAM. The typical memory amount for this system is about 32MB.


\subsection*{Sources}
\textbf{For Motorola 68HC11:}

\url{https://www.nxp.com/docs/en/reference-manual/M68HC11RM.pdf}

Page: 122

\textbf{For Intel i960:}

\url{https://www.alldatasheet.com/datasheet-pdf/download/93622/INTEL/I960.html}

Page: 1, 11

\section*{Was virtual memory supported for this architecture and how? Was it made using paging, segmentation, or both of these mechanisms?}
\subsection*{Motorola 68HC11}
The Motorola 68HC11 does not use paging, segmentation, and thus it does not implement virtual memory.

\subsection*{Intel i960}
This architecture also doesn't use paging or segmentation -  as a result, virtual memory is not implemented.

\subsection*{Sources}
\textbf{For Motorola 68HC11:}

\url{https://www.nxp.com/docs/en/reference-manual/M68HC11RM.pdf}

Page: 122

\textbf{For Intel i960:}

\url{https://www.alldatasheet.com/datasheet-pdf/download/93622/INTEL/I960.html}

Page: 1, 11

\section*{What was the command system for each architecture (ISA)? How many machine commands did each architecture have? What instruction formats did they support? Give 8 - 16 examples of instructions supported for each architecture. What instructions are similar? Which are different?}
\subsection*{Motorola 68HC11}
The type of command system (ISA) used by this architecture was the Motorola 68HC11 (an 8-bit CISC) instruction set, which supports a total of 149 machine commands. This architecture has a total of 6 supporting formats: INH (Inherit format), Immediate Format (IMM), Direct Format (DIR), Extended Format (EXT), Indexed Format (IND,X / IND,Y), Relative Format (REL). All of the instructions are divided among 4 classes: Accumulator and Memory Instructions, Stack and Index Register Instructions, Condition Code Register Instructions, Program Control Instructions. The most common instructions are: LDAA, LDX, LDY, ADDA, SUBA, INCA, DECA, ANDA, ORAA, ORAA, JSR, JMP, PSHA, PULA, BSET, BRSET.

\subsection*{Intel i960}
This architecture uses a 32-bit RISC architecture, which supports a total of 61 distinct machine commands. This architecture has a total of 4 different supporting formats: REG, MEM / MEMA / MEMB, CTRL, COBR. All of the instructions are divided among 7 different classes: Data movement, Arithmetic, Logical, Bit / bit-field / byte, Comparison and branch/control transfer, Fault, debug, and process control, and Atomic/multiprocessor support. The most common instructions are: ld, st, mov, add, sub, mul, div, and, or, xor, setbit, clrbit, notbit, cmp, call, ret.

\subsection*{Similar instructions}
Both of these architectures share similar instructions like: add, sub, cmp, ld, st, and, or, xor

\subsection*{Different instructions}
The Intel i960 has more expansive bitfield instructions like: extract, modify, it also supports large integer operations with instructions: movt (move 96-bit), movq (move 128-bit). The most important difference is that Intel i960 uses only registers for ALU operations, where Motorola 68HC11 ALU mainly works with accumulators A and B.

\subsection*{Sources}
\textbf{For Motorola 68HC11:}

\url{https://www.nxp.com/docs/en/reference-manual/M68HC11RM.pdf}

Pages: 215 - 227

\textbf{For Intel i960:}

\url{https://www.alldatasheet.com/datasheet-pdf/download/93622/INTEL/I960.html}

\url{https://datasheets.chipdb.org/Intel/80960/manuals/48527606.PDF?}

\url{https://stackoverflow.com/questions/52410521/is-zero-register-zr-in-aarch64-essentially-ground?}

\section*{What type of addressing methods did each architecture support? Which are similar, which are different?}
\subsection*{Motorola 68HC11}
This architecture has a total of 6 different addressing methods:

1) Immediate

2) Direct

3) Extended

4) Indexed (with either of two 16-bit index registers and an 8-bit offset)

5) Inherent

6) Relative

\subsection*{Intel i960}
This architecture uses a total of 8 different addressing methods: 

1) 12-bit offset (absolute)

2) 32-bit offset (absolute)

3) Register-indirect

4) Register + 12-bit offset

5) Register + 32-bit offset

6) Register + (index register × scale factor)

7) (Index register × scale factor) + 32-bit displacement

8) Register + (index register × scale factor) + 32-bit displacement

Where the The scale factor can be: 1, 2, 4, 8, or 16

\subsection*{Similar addressing methods}
1) Immediate - both architectures use the same core idea

2) Direct / Absolute addressing - both architectures use the same concept, but the sizes differ

3) Indexed addressing - in esence very simiar

\subsection*{Diffent addressing methods}
A list of unique addressing methods to intel i960:

1) Scaled index addressing

2) Scaled index + displacement

3) (index × scale) + 32-bit displacement

\bigskip
A list of unique addressing methods to Motorola 68HC11:

1) Inherent

2) Relative (8-bit branch offset)

\subsection*{Sources}
\textbf{For Motorola 68HC11:}

\url{https://www.nxp.com/docs/en/reference-manual/M68HC11RM.pdf}

Page: 206

\textbf{For Intel i960:}

\url{http://www.bitsavers.org/components/intel/i960/i960_Processors_and_Related_Products_Jan95.pdf}

Page: 20

\section*{What are the I/O possibilities of each architecture?}
\subsection*{Motorola 68HC11}
1) Timer System - captures input, displays output, used for the pulse accumulator

2) Pulse Accumulator - Counts external pulses or measures events

3) Analog-to-Digital Converter (A/D) - 8 channels, 8-bit resolution

4) SCI

5) SPI

6) Address/Data Bus I/O - outputs address/data


\subsection*{Intel i960}
1) Memory-mapped I/O - All peripherals are accessed as memory addresses

2) Local Bus (L-bus) - 32-bit multiplexed bus used to connect memory + I/O devices

3) PCI Bus I/O - Acts as a PCI device; supports PCI-to-PCI bridging

4) Address Translation Unit (ATU) - Maps PCI address space to local memory

5) DMA Controller - Performs high-speed peripheral-to-memory transfers with chaining, alignment

6) Interrupt Controller (ICU) - Handles up to 240 external interrupt sources

7) Interrupt Inputs (KB) - Flexible interrupt structure with on-chip or external interrupt controller options

8) Timer Unit - Two memory-mapped timer registers, each producing interrupts

10) I/O APIC Bus Interface - Multiprocessor I/O interrupt bus interface

11) Boundary Scan / JTAG - I/O test access

\subsection*{Sources}
\textbf{For Motorola 68HC11:}

\url{https://www.nxp.com/docs/en/reference-manual/M68HC11RM.pdf}

Pages: 162 - 164

\textbf{For Intel i960:}

\url{http://www.bitsavers.org/components/intel/i960/i960_Processors_and_Related_Products_Jan95.pdf}

Pages: 90, 91, 187 - 204

\url{https://www.alldatasheet.com/datasheet-pdf/download/93622/INTEL/I960.html}

Pages: 8, 9, 12

\section*{Were interrupts supported? How were interrupt mechanisms similar, how were they different for both architectures?}
\subsection*{Motorola 68CH11}
The given Intel architecture supported interrupts. These are the main categories with a short description:

1) Non-maskable interrupts - highest-priority events(ex. RESET, XIRQ)

2) External maskable interrupt - hardware interrupt triggered by an external signal(ex. IRQ)

3) Timer system interrupts - generated by the timer module for measuring pulses (ex. input capture, output compare)

4) Pulse accumulator interrupts - triggered by the 8-bit pulse counter subsystem (ex. Pulse Accumulator Overflow)

5) Serial communications interrupts - from SCI (UART) or SPI modules (ex. SCI Receive Full, SPI Transfer Complete)

6) A/D converter interrupts - triggered when an analog-to-digital conversion finishes (ex. A/D Conversion Complete)

7) Software interrupt - manually triggered by SWI instruction (ex. SWI)

\subsection*{Intel i960}
The given Intel architecture supported interrupts. These are the main categories with a short description:

1) Hardware interrupts - originates from external pins

2) Dedicated-mode interrupts - fixed vectors per pin

3) Expanded-mode interrupts - comes from from external hardware

4) Mixed-mode interrupts - combination of dedicated + expanded

5) DMA interrupts - 4 interrupt sources

6) Non-Maskable Interrupt (NMI) - highest-priority interrupt

7) Software interrupts - from system control instructions

8) Message-based interrupts (IAC) - from bus messages

9) Timer interrupts - per-timer interrupt signals

10) Faults (Exceptions) - arithmetic, trace

11) Trace interrupts - debug-related trace faults

\subsection*{Similarities in interrupt mechanisms}
1) Non-maskable interrupts - both CPUs implement a highest-priority interrupt

2) External maskable hardware interrupts - both architectures use external interrupt pins

3) Timer-based interrupts - both CPUs include timer units that generate interrupts

4) Software-generated interrupts - both support software-triggered interrupt exceptions for OS

\subsection*{Differences in interrupt mechanisms}
A list of unique interrupts native to only Intel i960:

1) Dedicated mode

2) Expanded mode

3) Mixed mode

4) DMA channel interrupts

5) Message-based interrupts

6) Trace interrupts

7) Faults and exceptions

\bigskip
A list of unique interrupts native to only Motorola 68HC11:

1) Pulse accumulator interrupts

2) ADC (Analog-to-Digital Converter) interrupts

\subsection*{Sources}
\textbf{For Motorola 68HC11:}

\url{https://www.nxp.com/docs/en/reference-manual/M68HC11RM.pdf}

Pages: 161 - 165

\textbf{For Intel i960:}

\url{http://www.bitsavers.org/components/intel/i960/i960_Processors_and_Related_Products_Jan95.pdf}

Pages: 173 - 174

\url{https://www.alldatasheet.com/datasheet-pdf/download/93622/INTEL/I960.html}

Page: 9

\section*{What data types did each architecture support? Were fixed, floating-point numbers supported, their arithmetic? Were integers represented as sign-size or as reverse code? Were there any other "exotic" data types?}

\subsection*{Motorola 68HC11}
The architecture natively supported four data types: bit data, 8-bit and 16-bit signed and unsigned integers, 3 16-bit unsigned fractions, and 16-bit addresses. Floating-point numbers were not supported, but fixed-point numbers were supported and used the mentioned 16-bit unsigned fraction data type for arithmetic. For integer types, the 68HC11 used two's complement. No "exotic" data types were listed in the data manual.

\subsection*{Intel i960}
This architecture supported a total of 7 native data types: signed and unsigned integers (of width: 8, 16, 32, 64 bits), bits, bit fields, and fixed, floating-point numbers (32-bit, 64-bit, 80-bit extended precision, IEEE-754 compliant). Integer types were represented using two's complement. This architecture has a few "exotic" data types like triple word (96 bits) and quad word (128 bits).


\subsection*{Sources}
\textbf{For Motorola 68HC11:}

\url{https://www.nxp.com/docs/en/reference-manual/M68HC11RM.pdf}

\url{https://www.nxp.com/docs/en/reference-manual/M68HC11RM.pdf}

\url{https://www.nxp.com/docs/en/data-sheet/M68HC11E.pdf}

\textbf{For Intel i960}

\url{http://www.bitsavers.org/components/intel/i960/i960_Processors_and_Related_Products_Jan95.pdf}


\end{document}