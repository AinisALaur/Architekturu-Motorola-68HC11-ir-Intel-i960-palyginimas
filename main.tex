\documentclass[
    english
]{VUMIFPSbakalaurinis}
\usepackage{float}
\usepackage{wrapfig2}
\usepackage{hyperref}
\usepackage{algorithmicx}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{bm}
\usepackage{caption}
\usepackage{color}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{subcaption}

\university{Vilnius university}
\faculty{Faculty of Mathematics and Informatics}
\department{Informatics bachelor's degree studies}
\title{Two chosen computer architecture comparison}
\papertype{Motorola 68HC11 vs. Intel i960}

\author{Ainis Augustas Laurinavičius}
\supervisor{prof. dr. Saulius Gražulis}
\date{Vilnius – \the\year}

\bibliography{bibliografija}

\begin{document}
\maketitle

\newpage
\section*{Base of the processor/computer, physical characteristics}
\subsection*{Motorola 68HC11}
The base of this architecture is made from CMOS MOSFET transistors, an integrated circuit (IC) with a very large scale of integration (VLSI). This processor is a monocrystalline modern processor. The processor is about 20 mm in length and 20 mm in width; its weight is not specified. During operation, the processor uses 5 V at a frequency of 2 MHz, and the current ranges between 5 and 15 mA. When the operating frequency is increased to 3–4 MHz, the current ranges from 8 to 20 mA. In STOP mode (low-power), the processor uses less — about 10 $\mu$A, and in sleep mode (WAIT), the current is not precisely specified. The processor’s power consumption during operation is between 50 and 100 mW. \cite{motorolaGrok} \cite{motorolaMicRefManual}

\subsection*{Intel i960}
The base of this architecture is composed of CMOS transistors and an integrated circuit with a very large scale of integration (VLSI). This processor is a monocrystalline modern processor. The processor is about 35 mm in length and 35 mm in width, weighing about 50 g. During operation, the processor uses 3.3 V at a 25 MHz frequency, with a current of about 150 mA. When the operating frequency is increased to 33 MHz, the current increases to 200 mA. In STOP mode (low-power), the processor uses only 10–20 mA, and in sleep mode (WAIT) it uses 37–75 mA. The processor’s power consumption during operation is about 0.033 W. \cite{intelProcessors} \cite{i960assemblerGuide}

\section*{What type of architecture did the computer use?}
\subsection*{Motorola 68HC11}
This architecture had an 8-bit accumulator, a stack pointer, which is not used for operations, a program counter, and registers that support 72 instructions and 19 extended opcodes. All operations are performed between registers or in the accumulator rather than in memory, so this processor’s architecture is accumulator/register based. \cite{motorolaGrok}

\subsection*{Intel i960}
This architecture is made of registers, a stack pointer, which is not used for operations. It does not have an accumulator and uses load/store instructions. All operations are performed between registers rather than in memory, so this processor’s architecture is register-based, which uses load/store instructions. \cite{intelGrok}

\section*{Was it a zero-address (stack-based), one-address, two-address, three-address, or four-address machine?}
\subsection*{Motorola 68HC11}
This architecture is a 1–2-address machine, where the number of addresses depends on the operation, and it never uses more than two. The architecture has a stack, but it is not used for operations (‘The M68HC11 CPU automatically supports a program stack… used for subroutines, interrupts, and temporary storage.’ — a quote from the Motorola 68HC11 Reference Manual).\cite{motorolaMicRefManual}

\subsection*{Intel i960}
This architecture uses mostly 2 addresses. There is no one-address or three-address operation within this architecture. The architecture has a stack, but it is not used for operations (quote from the i960 Intel Datasheet: ‘it does not consume/produce operands on a stack’).\cite{intelDatasheet}

\section*{What registers existed in both architectures? What kind of registers were they? How many registers were there? What were the data widths of the registers? What was the specific purpose of each register?}
\subsection*{Motorola 68HC11}
The architecture has 8 registers (A, B, D, X, Y, SP, PC, CCR), and all registers are global. Registers A, B, and CCR are 8 bits wide, while the others are 16 bits wide. Registers SP and CCR have special purposes—SP is the stack pointer register, and CCR is the Condition Code Register. The PC register is the Program Counter. Registers X and Y are used for indexing but can also serve as general-purpose registers, while the remaining registers (A, B, D) are general-purpose registers.\cite{motorolaMicRefManual}

\subsection*{Intel i960}
The architecture consists of 32 registers (16 global and 16 local general-purpose), and all registers are 32 bits wide. The special-purpose registers are: PC/IP (Instruction Pointer), AC (Arithmetic Condition Codes), and MMRs (used to control interrupts, counters, and program errors).\cite{intelDatasheet}

\section*{Were flag bits used in these architectures? Which flags were used?}
\subsection*{Motorola 68HC11}
Yes, this architecture uses flag bits—the CCR register contains 5 flag bits. The flag bits are: C (Carry/Borrow), V (Overflow), Z (Zero), N (Negative), and H (Half-carry).\cite{motorolaMicRefManual}

\subsection*{Intel i960}
Yes, this architecture also uses flag bits. The flag bits are: C (Carry/Borrow), V (Two’s complement overflow indicator), Z (Zero indicator), N (Negative indicator), and T (Trace-enable, used for program debugging).\cite{intelDatasheet}

\section*{What was the data width (machine word) of each architecture?}
\subsection*{Motorola 68HC11}
The machine word for this architecture is 8 bits long.\cite{motorolaGrok}

\subsection*{Intel i960}
The machine word for this architecture is 32 bits long.\cite{intelDatasheet}

\section*{Memory layout of each system. Address width. The maximum possible amount of memory in each system. Typical amount of memory with which the system was used}

\subsection*{Motorola 68HC11}
This architure's memory is flat and linearly stored in a 64KB address space - the memory is not segmented, nor paged, nor stored in memory banks. The effective address width is 16 bits and the maximum amount of memory stored in the system was 64KB. The typical memory amount for this system is about 256–512 bytes of RAM and 8–12 KB of program memory.\cite{motorolaMicRefManual}

\subsection*{Intel i960}
This architecture's memory layout is not segmented, nor does it use pages, but it does use memory banks(regions). The effective adress width was 32 bits and the maximum amount of memory stored in the system was up to 256 Mbytes of 32- or 36-Bit DRAM. The typical memory amount for this system is about 32MB.\cite{intelDatasheet}

\section*{Was virtual memory supported for this architecture and how? Was it made using paging, segmentation, or both of these mechanisms?}
\subsection*{Motorola 68HC11}
The Motorola 68HC11 does not use paging, segmentation, and thus it does not implement virtual memory.\cite{motorolaMicRefManual}

\subsection*{Intel i960}
This architecture also doesn't use paging or segmentation -  as a result, virtual memory is not implemented.\cite{intelDatasheet}

\section*{What was the command system for each architecture (ISA)? How many machine commands did each architecture have? What instruction formats did they support? Give 8 - 16 examples of instructions supported for each architecture. What instructions are similar? Which are different?}

\subsection*{Motorola 68HC11}
The type of command system (ISA) used by this architecture was the Motorola 68HC11 (an 8-bit CISC) instruction set, which supports a total of 149 machine commands. This architecture has a total of 6 supporting formats: INH (Inherit format), Immediate Format (IMM), Direct Format (DIR), Extended Format (EXT), Indexed Format (IND,X / IND,Y), Relative Format (REL). All of the instructions are divided among 4 classes: Accumulator and Memory Instructions, Stack and Index Register Instructions, Condition Code Register Instructions, Program Control Instructions. The most common instructions are: LDAA, LDX, LDY, ADDA, SUBA, INCA, DECA, ANDA, ORAA, ORAA, JSR, JMP, PSHA, PULA, BSET, BRSET.\cite{motorolaMicRefManual}

\subsection*{Intel i960}
This architecture uses a 32-bit RISC architecture, which supports a total of 61 distinct machine commands. This architecture has a total of 4 different supporting formats: REG, MEM / MEMA / MEMB, CTRL, COBR. All of the instructions are divided among 7 different classes: Data movement, Arithmetic, Logical, Bit / bit-field / byte, Comparison and branch/control transfer, Fault, debug, and process control, and Atomic/multiprocessor support. The most common instructions are: ld, st, mov, add, sub, mul, div, and, or, xor, setbit, clrbit, notbit, cmp, call, ret.\cite{intelDatasheet} \cite{i960assemblerGuide}

\subsection*{Similar instructions}
Both of these architectures share similar instructions like: add, sub, cmp, ld, st, and, or, xor

\subsection*{Different instructions}
The Intel i960 has more expansive bitfield instructions like: extract, modify, it also supports large integer operations with instructions: movt (move 96-bit), movq (move 128-bit). The most important difference is that Intel i960 uses only registers for ALU operations, where Motorola 68HC11 ALU mainly works with accumulators A and B.

\section*{What type of addressing methods did each architecture support? Which are similar, which are different?}
\subsection*{Motorola 68HC11}
This architecture has a total of 6 different addressing methods:

1) Immediate

2) Direct

3) Extended

4) Indexed (with either of two 16-bit index registers and an 8-bit offset)

5) Inherent

6) Relative

\cite{motorolaMicRefManual}

\subsection*{Intel i960}
This architecture uses a total of 8 different addressing methods: 

1) 12-bit offset (absolute)

2) 32-bit offset (absolute)

3) Register-indirect

4) Register + 12-bit offset

5) Register + 32-bit offset

6) Register + (index register × scale factor)

7) (Index register × scale factor) + 32-bit displacement

8) Register + (index register × scale factor) + 32-bit displacement

Where the The scale factor can be: 1, 2, 4, 8, or 16

\cite{intelProcessors}

\subsection*{Similar addressing methods}
1) Immediate - both architectures use the same core idea

2) Direct / Absolute addressing - both architectures use the same concept, but the sizes differ

3) Indexed addressing - in esence very simiar

\subsection*{Diffent addressing methods}
A list of unique addressing methods to intel i960:

1) Scaled index addressing

2) Scaled index + displacement

3) (index × scale) + 32-bit displacement

\bigskip
A list of unique addressing methods to Motorola 68HC11:

1) Inherent

2) Relative (8-bit branch offset)

\section*{What are the I/O possibilities of each architecture?}
\subsection*{Motorola 68HC11}
1) Timer System - captures input, displays output, used for the pulse accumulator

2) Pulse Accumulator - Counts external pulses or measures events

3) Analog-to-Digital Converter (A/D) - 8 channels, 8-bit resolution

4) SCI

5) SPI

6) Address/Data Bus I/O - outputs address/data

\cite{motorolaMicRefManual}

\subsection*{Intel i960}
1) Memory-mapped I/O - All peripherals are accessed as memory addresses

2) Local Bus (L-bus) - 32-bit multiplexed bus used to connect memory + I/O devices

3) PCI Bus I/O - Acts as a PCI device; supports PCI-to-PCI bridging

4) Address Translation Unit (ATU) - Maps PCI address space to local memory

5) DMA Controller - Performs high-speed peripheral-to-memory transfers with chaining, alignment

6) Interrupt Controller (ICU) - Handles up to 240 external interrupt sources

7) Interrupt Inputs (KB) - Flexible interrupt structure with on-chip or external interrupt controller options

8) Timer Unit - Two memory-mapped timer registers, each producing interrupts

10) I/O APIC Bus Interface - Multiprocessor I/O interrupt bus interface

11) Boundary Scan / JTAG - I/O test access


\cite{intelProcessors} \cite{intelDatasheet}

\section*{Were interrupts supported? How were interrupt mechanisms similar, how were they different for both architectures?}
\subsection*{Motorola 68CH11}
The given Intel architecture supported interrupts. These are the main categories with a short description:

1) Non-maskable interrupts - highest-priority events(ex. RESET, XIRQ)

2) External maskable interrupt - hardware interrupt triggered by an external signal(ex. IRQ)

3) Timer system interrupts - generated by the timer module for measuring pulses (ex. input capture, output compare)

4) Pulse accumulator interrupts - triggered by the 8-bit pulse counter subsystem (ex. Pulse Accumulator Overflow)

5) Serial communications interrupts - from SCI (UART) or SPI modules (ex. SCI Receive Full, SPI Transfer Complete)

6) A/D converter interrupts - triggered when an analog-to-digital conversion finishes (ex. A/D Conversion Complete)

7) Software interrupt - manually triggered by SWI instruction (ex. SWI)

\cite{motorolaMicRefManual}
\subsection*{Intel i960}
The given Intel architecture supported interrupts. These are the main categories with a short description:

1) Hardware interrupts - originates from external pins

2) Dedicated-mode interrupts - fixed vectors per pin

3) Expanded-mode interrupts - comes from from external hardware

4) Mixed-mode interrupts - combination of dedicated + expanded

5) DMA interrupts - 4 interrupt sources

6) Non-Maskable Interrupt (NMI) - highest-priority interrupt

7) Software interrupts - from system control instructions

8) Message-based interrupts (IAC) - from bus messages

9) Timer interrupts - per-timer interrupt signals

10) Faults (Exceptions) - arithmetic, trace

11) Trace interrupts - debug-related trace faults

\cite{intelProcessors} \cite{intelDatasheet}

\subsection*{Similarities in interrupt mechanisms}
1) Non-maskable interrupts - both CPUs implement a highest-priority interrupt

2) External maskable hardware interrupts - both architectures use external interrupt pins

3) Timer-based interrupts - both CPUs include timer units that generate interrupts

4) Software-generated interrupts - both support software-triggered interrupt exceptions for OS

\subsection*{Differences in interrupt mechanisms}
A list of unique interrupts native to only Intel i960:

1) Dedicated mode

2) Expanded mode

3) Mixed mode

4) DMA channel interrupts

5) Message-based interrupts

6) Trace interrupts

7) Faults and exceptions

\bigskip
A list of unique interrupts native to only Motorola 68HC11:

1) Pulse accumulator interrupts

2) ADC (Analog-to-Digital Converter) interrupts

\section*{What data types did each architecture support? Were fixed, floating-point numbers supported, their arithmetic? Were integers represented as sign-size or as reverse code? Were there any other "exotic" data types?}

\subsection*{Motorola 68HC11}
The architecture natively supported four data types: bit data, 8-bit and 16-bit signed and unsigned integers, 3 16-bit unsigned fractions, and 16-bit addresses. Floating-point numbers were not supported, but fixed-point numbers were supported and used the mentioned 16-bit unsigned fraction data type for arithmetic. For integer types, the 68HC11 used two's complement. No "exotic" data types were listed in the data manual.\cite{motorolaFamily} \cite{motorolaMicRefManual}

\subsection*{Intel i960}
This architecture supported a total of 7 native data types: signed and unsigned integers (of width: 8, 16, 32, 64 bits), bits, bit fields, and fixed, floating-point numbers (32-bit, 64-bit, 80-bit extended precision, IEEE-754 compliant). Integer types were represented using two's complement. This architecture has a few "exotic" data types like triple word (96 bits) and quad word (128 bits). \cite{intelProcessors}

\section*{What was the performance of each system? What were the clock generator frequencies, and what were the average/minimum/maximum number of cycles required to execute each instruction, and what was the average system performance? Which system was more efficient? What was the price–performance ratio?}

\subsection*{Motorola 68HC11}
The system's clock is called the E-clock, which has a frequency of $\frac{1}{4}$ of the external crystal frequency, the operating frequency could go up to 3 MHz. Some examples of required cycle count per instruction: LDAA (3 cycles), JSR (6 cycles), LDX (4 cycles), JMP (3 cycles). The maximum number of cycles is about 14, used by interrupt entries. The minimum number of cycles is only about 2. On average, most instructions use about 2 - 4 cycles, and longer non-interrupt instructions use about 7 cycles. The average speed of the microcontroller was about 0.2 MIPS.

\cite{motorolaMicRefManual} \cite{motorolaEvalModule}

\subsection*{Intel i960}
This system uses a 32MHz internal core frequency, and the data sheet does not provide information about an E-clock as the Motorola 68CH11 architectures did. According to the instruction manual, it is given that most instructions are executed in a single clock cycle, thus, the minimum is clearly 1 cycle. Per average an instruction is finished in just 0.5 cycles, meaning the system can execute two instructions per cycle. The maximum number of cycles is not listed. According to the table, which depicts the system's performance, it is given that the average performance was about 66 MIPS.\cite{intelProcessors}

\subsection*{Comparison}
The Intel i960 system is clearly superior to the Motorola 68CH11 performance-wise. The Motorola 68CH11 at its release cost about 250 USD, and the Intel i960 was 174 USD (the base KA model, the better KB model was 333 USD), so clearly the Intel i960 was the better choice as it delivered more for a lower price.

\section*{Did the architectures use cache memory? If so, what size?}
\subsection*{Motorola 68CH11}
This system did not use cache memory.\cite{motorolaMicRefManual}

\subsection*{intel i960}
This system used cache memory for instructions and data. The instruction cache size completely depended on the model of the CPU, but generally it ranged between 512 bytes to 4KB, meanwhile the data cache ranged from 0 to 2KB.\cite{intelProcessors}

\section*{What were the typical use cases for each architecture? Write a brief paragraph of an example use case}
\subsection*{Motorola 68CH11}
This processor is used for educational purposes to teach students the workings of a processor. Moreover, this CPU is used in automotive applications, barcode readers, hotel card key writers, and various other embedded systems. This microcontroller found itself being used a lot in the automotive industry especially for engine control units for managing air/fuel flow sensors, spark timing, and odometer functions requiring durable non-volatile memory.\cite{motorola68HC11x} \cite{motorolaGrok}

\subsection*{intel i960}
The processor was used for high-end embedded systems, networking, it also appeared in consumer and commercial devices, such as Sega's Daytona USA arcade games, early GPS receivers, and video poker machines. Additionally, the Intel i960 processor family was deployment in several specialized military applications, it was engineered for high-reliability embedded systems in defense environments. These processors supported real-time operations in avionics for aircraft control, such as in the F-22 Raptor, missile guidance systems requiring precise computation under stringent timing constraints, and radar signal processing for target detection and tracking.\cite{intelGrok}

\section*{How much software was written for each architecture, is it (still) available? What compilers and programming tools (debuggers, profilers, assemblers) were available? What software libraries were available?}

\subsection*{Motorola 68CH11}
No sources provide a numerical estimate of how much software was written for the Motorola 68HC11, but taking into account all of the use cases - its in the hundreds of millions. For this architecture there were several tools available: the GNU Development Chain — including a C/C++ compiler (GCC), assembler/linker (Binutils), debugger (GDB), and C runtime libraries (NEWLIB: libc, libm, etc.). The GNU tool chain is still available today.\cite{GNUdevChain} \cite{motorolaGrok}

\subsection*{Intel i960}
Again, there are no concrete numbers depicting how much software was written using the Intel i960 architecture, but comparing it to the Motorola 68CH11 it is clear that its applicability was greater, also taking into account its popularity I assume the number is in the billions. This architecture had a richer software system: Developers used standard C runtime libraries (libc, libm), large commercial toolchains for compiling, debbuging, assembling and linking (Intel iC960, GNU i960 tools, Green Hills, Diab), and extensive RTOS libraries. Some software still remains and is accesible like the open-source GNU/960 toolchain, but Intels commercial tools like the iC960 is no longer available from Intel.\cite{intelGrok} \cite{intelProcessors}

\section*{Emulators}
\subsection*{Motorola 68CH11}
\url{http://www.hc11.demon.nl/thrsim11/thrsim11.htm}

\subsection*{Intel i960}
\url{https://virtuallyfun.com/2010/01/19/qemu-12-2/}

\nocite{*}
\printbibliography

\end{document}